/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type CommonExpression = OpExpression | SimpleExpression;

export const CommonExpression = 'CommonExpression';

export function isCommonExpression(item: unknown): item is CommonExpression {
    return reflection.isInstance(item, CommonExpression);
}

export type PatternDefinition = And | Or | SimplePatternDefinition;

export const PatternDefinition = 'PatternDefinition';

export function isPatternDefinition(item: unknown): item is PatternDefinition {
    return reflection.isInstance(item, PatternDefinition);
}

export type SimpleExpression = BooleanLiteral | DecimalLiteral | IntegerLiteral | StringLiteral | VariableAccess;

export const SimpleExpression = 'SimpleExpression';

export function isSimpleExpression(item: unknown): item is SimpleExpression {
    return reflection.isInstance(item, SimpleExpression);
}

export type SimplePatternDefinition = Anything | BooleanLiteral | BooleanType | DecimalLiteral | DecimalType | Expression | IntegerLiteral | IntegerType | ListDefinition | LocalPatternReference | ObjectDefinition | PatternReference | StringLiteral | StringType;

export const SimplePatternDefinition = 'SimplePatternDefinition';

export function isSimplePatternDefinition(item: unknown): item is SimplePatternDefinition {
    return reflection.isInstance(item, SimplePatternDefinition);
}

export interface And extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    right: PatternDefinition
}

export const And = 'And';

export function isAnd(item: unknown): item is And {
    return reflection.isInstance(item, And);
}

export interface Anything extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'Anything';
}

export const Anything = 'Anything';

export function isAnything(item: unknown): item is Anything {
    return reflection.isInstance(item, Anything);
}

export interface Argument extends AstNode {
    readonly $container: Arguments;
    readonly $type: 'Argument';
    name: string
}

export const Argument = 'Argument';

export function isArgument(item: unknown): item is Argument {
    return reflection.isInstance(item, Argument);
}

export interface Arguments extends AstNode {
    readonly $container: Pattern;
    readonly $type: 'Arguments';
    arguments: Array<Argument>
}

export const Arguments = 'Arguments';

export function isArguments(item: unknown): item is Arguments {
    return reflection.isInstance(item, Arguments);
}

export interface Attribute extends AstNode {
    readonly $container: Field | Pattern;
    readonly $type: 'Attribute';
    entries: Array<AttributeEntry>
    name: string
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface AttributeEntry extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'AttributeEntry';
    name: string
    value?: AttributeValue
}

export const AttributeEntry = 'AttributeEntry';

export function isAttributeEntry(item: unknown): item is AttributeEntry {
    return reflection.isInstance(item, AttributeEntry);
}

export interface AttributeValue extends AstNode {
    readonly $container: AttributeEntry;
    readonly $type: 'AttributeValue';
    value: string
}

export const AttributeValue = 'AttributeValue';

export function isAttributeValue(item: unknown): item is AttributeValue {
    return reflection.isInstance(item, AttributeValue);
}

export interface BooleanLiteral extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'BooleanLiteral';
    value: 'false' | 'true'
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface BooleanType extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'BooleanType';
}

export const BooleanType = 'BooleanType';

export function isBooleanType(item: unknown): item is BooleanType {
    return reflection.isInstance(item, BooleanType);
}

export interface CompilationUnit extends AstNode {
    readonly $type: 'CompilationUnit';
    patterns: Array<Pattern>
}

export const CompilationUnit = 'CompilationUnit';

export function isCompilationUnit(item: unknown): item is CompilationUnit {
    return reflection.isInstance(item, CompilationUnit);
}

export interface DecimalLiteral extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'DecimalLiteral';
    value: number
}

export const DecimalLiteral = 'DecimalLiteral';

export function isDecimalLiteral(item: unknown): item is DecimalLiteral {
    return reflection.isInstance(item, DecimalLiteral);
}

export interface DecimalType extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'DecimalType';
}

export const DecimalType = 'DecimalType';

export function isDecimalType(item: unknown): item is DecimalType {
    return reflection.isInstance(item, DecimalType);
}

export interface Expression extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'Expression';
    expression?: CommonExpression
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Field extends AstNode {
    readonly $container: ObjectDefinition;
    readonly $type: 'Field';
    attributes: Array<Attribute>
    definition: PatternDefinition
    name: string
    optional: boolean
}

export const Field = 'Field';

export function isField(item: unknown): item is Field {
    return reflection.isInstance(item, Field);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'IntegerLiteral';
    value: number
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface IntegerType extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'IntegerType';
}

export const IntegerType = 'IntegerType';

export function isIntegerType(item: unknown): item is IntegerType {
    return reflection.isInstance(item, IntegerType);
}

export interface ListDefinition extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'ListDefinition';
    entries: Array<PatternDefinition>
}

export const ListDefinition = 'ListDefinition';

export function isListDefinition(item: unknown): item is ListDefinition {
    return reflection.isInstance(item, ListDefinition);
}

export interface LocalPatternReference extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'LocalPatternReference';
    parameters?: Parameters
    ref: Reference<Pattern>
    refinement?: Refinement
}

export const LocalPatternReference = 'LocalPatternReference';

export function isLocalPatternReference(item: unknown): item is LocalPatternReference {
    return reflection.isInstance(item, LocalPatternReference);
}

export interface ObjectDefinition extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'ObjectDefinition';
    fields: Array<Field>
}

export const ObjectDefinition = 'ObjectDefinition';

export function isObjectDefinition(item: unknown): item is ObjectDefinition {
    return reflection.isInstance(item, ObjectDefinition);
}

export interface OpExpression extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    right: CommonExpression
}

export const OpExpression = 'OpExpression';

export function isOpExpression(item: unknown): item is OpExpression {
    return reflection.isInstance(item, OpExpression);
}

export interface Or extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    right: PatternDefinition
}

export const Or = 'Or';

export function isOr(item: unknown): item is Or {
    return reflection.isInstance(item, Or);
}

export interface Parameter extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    deref: boolean
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface Parameters extends AstNode {
    readonly $container: LocalPatternReference | PatternReference;
    readonly $type: 'Parameters';
    parameters: Array<Parameter>
}

export const Parameters = 'Parameters';

export function isParameters(item: unknown): item is Parameters {
    return reflection.isInstance(item, Parameters);
}

export interface Pattern extends AstNode {
    readonly $container: CompilationUnit;
    readonly $type: 'Pattern';
    arguments?: Arguments
    attributes: Array<Attribute>
    definition: PatternDefinition
    name: string
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface PatternReference extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'PatternReference';
    package: Array<string>
    parameters?: Parameters
    ref: string
    refinement?: Refinement
}

export const PatternReference = 'PatternReference';

export function isPatternReference(item: unknown): item is PatternReference {
    return reflection.isInstance(item, PatternReference);
}

export interface Refinement extends AstNode {
    readonly $container: LocalPatternReference | PatternReference;
    readonly $type: 'Refinement';
    refinements: PatternDefinition
}

export const Refinement = 'Refinement';

export function isRefinement(item: unknown): item is Refinement {
    return reflection.isInstance(item, Refinement);
}

export interface StringLiteral extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'StringLiteral';
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface StringType extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'StringType';
}

export const StringType = 'StringType';

export function isStringType(item: unknown): item is StringType {
    return reflection.isInstance(item, StringType);
}

export interface VariableAccess extends AstNode {
    readonly $container: And | Expression | Field | ListDefinition | OpExpression | Or | Parameters | Pattern | Refinement;
    readonly $type: 'VariableAccess';
}

export const VariableAccess = 'VariableAccess';

export function isVariableAccess(item: unknown): item is VariableAccess {
    return reflection.isInstance(item, VariableAccess);
}

export interface SeedwingDogmaAstType {
    And: And
    Anything: Anything
    Argument: Argument
    Arguments: Arguments
    Attribute: Attribute
    AttributeEntry: AttributeEntry
    AttributeValue: AttributeValue
    BooleanLiteral: BooleanLiteral
    BooleanType: BooleanType
    CommonExpression: CommonExpression
    CompilationUnit: CompilationUnit
    DecimalLiteral: DecimalLiteral
    DecimalType: DecimalType
    Expression: Expression
    Field: Field
    IntegerLiteral: IntegerLiteral
    IntegerType: IntegerType
    ListDefinition: ListDefinition
    LocalPatternReference: LocalPatternReference
    ObjectDefinition: ObjectDefinition
    OpExpression: OpExpression
    Or: Or
    Parameter: Parameter
    Parameters: Parameters
    Pattern: Pattern
    PatternDefinition: PatternDefinition
    PatternReference: PatternReference
    Refinement: Refinement
    SimpleExpression: SimpleExpression
    SimplePatternDefinition: SimplePatternDefinition
    StringLiteral: StringLiteral
    StringType: StringType
    VariableAccess: VariableAccess
}

export class SeedwingDogmaAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['And', 'Anything', 'Argument', 'Arguments', 'Attribute', 'AttributeEntry', 'AttributeValue', 'BooleanLiteral', 'BooleanType', 'CommonExpression', 'CompilationUnit', 'DecimalLiteral', 'DecimalType', 'Expression', 'Field', 'IntegerLiteral', 'IntegerType', 'ListDefinition', 'LocalPatternReference', 'ObjectDefinition', 'OpExpression', 'Or', 'Parameter', 'Parameters', 'Pattern', 'PatternDefinition', 'PatternReference', 'Refinement', 'SimpleExpression', 'SimplePatternDefinition', 'StringLiteral', 'StringType', 'VariableAccess'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case And:
            case Or: {
                return this.isSubtype(PatternDefinition, supertype);
            }
            case Anything:
            case BooleanType:
            case DecimalType:
            case Expression:
            case IntegerType:
            case ListDefinition:
            case LocalPatternReference:
            case ObjectDefinition:
            case PatternReference:
            case StringType: {
                return this.isSubtype(SimplePatternDefinition, supertype);
            }
            case BooleanLiteral:
            case DecimalLiteral:
            case IntegerLiteral:
            case StringLiteral: {
                return this.isSubtype(SimpleExpression, supertype) || this.isSubtype(SimplePatternDefinition, supertype);
            }
            case OpExpression: {
                return this.isSubtype(CommonExpression, supertype);
            }
            case PatternDefinition: {
                return this.isSubtype(Parameter, supertype);
            }
            case SimpleExpression: {
                return this.isSubtype(CommonExpression, supertype) || this.isSubtype(OpExpression, supertype);
            }
            case SimplePatternDefinition: {
                return this.isSubtype(And, supertype) || this.isSubtype(Or, supertype) || this.isSubtype(PatternDefinition, supertype);
            }
            case VariableAccess: {
                return this.isSubtype(SimpleExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'LocalPatternReference:ref': {
                return Pattern;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Arguments': {
                return {
                    name: 'Arguments',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'Attribute': {
                return {
                    name: 'Attribute',
                    mandatory: [
                        { name: 'entries', type: 'array' }
                    ]
                };
            }
            case 'CompilationUnit': {
                return {
                    name: 'CompilationUnit',
                    mandatory: [
                        { name: 'patterns', type: 'array' }
                    ]
                };
            }
            case 'Field': {
                return {
                    name: 'Field',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'optional', type: 'boolean' }
                    ]
                };
            }
            case 'ListDefinition': {
                return {
                    name: 'ListDefinition',
                    mandatory: [
                        { name: 'entries', type: 'array' }
                    ]
                };
            }
            case 'ObjectDefinition': {
                return {
                    name: 'ObjectDefinition',
                    mandatory: [
                        { name: 'fields', type: 'array' }
                    ]
                };
            }
            case 'Parameter': {
                return {
                    name: 'Parameter',
                    mandatory: [
                        { name: 'deref', type: 'boolean' }
                    ]
                };
            }
            case 'Parameters': {
                return {
                    name: 'Parameters',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Pattern': {
                return {
                    name: 'Pattern',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'PatternReference': {
                return {
                    name: 'PatternReference',
                    mandatory: [
                        { name: 'package', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SeedwingDogmaAstReflection();
